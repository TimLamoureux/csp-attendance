<?php

/**
 * CSP_Attendance
 *
 * @package   CSP_Attendance
 * @author    Tim Lamoureux <tim@wcubemedia.com>
 * @copyright 2019 wCube Media
 * @license   GPL 2.0+
 * @link      https://wcubemedia.com
 */

class Ca_Report extends Ca_Base {

	protected $pod;

	protected $date_range = array(
		'from' => '',
		'to' => ''
	);

	/**
	 * @var $args represents some limits to the amount of data generated by the report,
	 *                         for example which user. That way, users will be able to generate reports
	 *                         of their own activity. What is the best way to implement?
	 */
	protected $args = array(
		'event_id' => '',
		'group_id' => '', // must be the team ID
		'category' => '',
		'type' => '', // must be csp, pro or junior.
		'user_id' => '',
		'bookings' => false,    // Compares bookings vs attendance
		'compare_event_length' => false, // Compares attendance length vs event length
		'time_after_start' => 0, // Users after this period of time (in minutes) from the start time won't have full attendance
		'time_before_end' => 0 //Users before this period of time (in minutes) from the end time won't have full attendance
	);


	protected $date_generated;

	protected $report;



	/**
	 * CA_Report constructor.
	 *
	 * @param DateTime $from
	 * @param DateTime $to
	 */
	public function __construct( array $args = [], DateTime $from = null, DateTime $to = null ) {

		$this->pod = pods( CA_ATTENDANCE_CPT );
		if ( false === $this->pod ) {
			/*unset( $this );*/
			throwException( new Exception( 'Cannot find the custom post type required to generate the report' ) );
		}

		// TODO: Validate $args
		$this->args = array_merge( $this->args, $args );

		$this->set_dates( $from, $to );

	}

	/**
	 * Initialize the class
	 */
	public function initialize() {
		parent::initialize();
	}

	private function set_dates( DateTime $from = null, DateTime $to = null ) {
		if ( is_null( $from ) ) {
			//throw new Exception( 'Reports cannot be generated without a start date' );
			$from = new DateTime( 'yesterday', new DateTimeZone( CA_TIMEZONE ) );
		}

		if ( is_null( $to ) ) {
			$to = new DateTime( 'now', new DateTimeZone( CA_TIMEZONE ) );
		}

		// Make sure $from is smaller than $to, otherwise swap dates
		if ( $from > $to ) {
			$tmp = $to;
			$to = $from;
			$from = $tmp;
			unset( $tmp );
		}

		$this->date_range = [
			'from' => $from,
			'to' => $to->setTime( 0, 0 )->add( new DateInterval( 'P1D' ) ) // Updates the date to next day at midnight to include events for the whole last day
		];
	}

	/**
	 *
	 */
	public function generate_report() {
		$p = $this->pod;

		$query = $this->event_query();
		$p->find( $query );

		$bookings = array();
		$report_users = array();
		$report_events = array(); // This will be sent via JSON
		$events = array(); // This stores all events parsed to minimize queries to Event Manager


		while ( $p->fetch() ) {

			$patroller_id = $p->field( 'patroller_id.ID' );
			$event_id = $p->field( 'event_id' );
			$time_in = new DateTime( $p->field( 'time_in' ), new DateTimeZone( CA_TIMEZONE ) );
			$time_out = new DateTime( $p->field( 'time_out' ), new DateTimeZone( CA_TIMEZONE ) );

			$event = null;

			/**
			 * Check if we already processed this event for another attendance before
			 */
			//if ( $event_id != $event->id ) {
			if ( empty( $events[ $event_id ] ) ) {

				$event = reset( EM_Events::get( array( $event_id ) ) );


				/** Fetch all category id related to this event.
				 *  Useful to see if this event belongs in the requested category
				 *
				 */
				$event->categories_array = array();
				foreach ( $event->get_categories()->terms as $category ) {
					$event->categories_array[] = $category->id;
				}

				$max_start = new DateTime( $event->start_date . ' ' . $event->start_time, new DateTimeZone( CA_TIMEZONE ) );
				$event->max_start = $max_start->modify( "+{$this->args['time_after_start']} minutes" );

				$min_end = new DateTime( $event->end_date . ' ' . $event->end_time, new DateTimeZone( CA_TIMEZONE ) );
				$event->min_end = $min_end->modify( "-{$this->args['time_before_end']} minutes" );

				$event_bookings = EM_Bookings::get( array(
					'blog' => 0,
					'event' => $event_id,
					'scope' => "",
					'bookings' => true,
					'category' => $this->args['category'],
					'status' => 1,
					'array' => true
				) );

				foreach ( $event_bookings as $e ) {
					$bookings[ $event_id ][] = $e['person_id'];
				}
				unset( $event_bookings );

				if ( ! empty( $bookings[ $event_id ] ) )
					$event->bookings = &$bookings[ $event_id ];

				$events[ $event_id ] = $event;
			} else {
				$event = $events[ $event_id ];
			}


			/**
			 * Skip this attendance if it is not for an event belonging to the requested category
			 */
			if ( $this->args['category'] && ! in_array( $this->args['category'], $event->categories_array ) ) {
				continue;
			}


			// First time patroller is encountered in report, create its entry in the report_users array
			if ( empty( $report_users[ $patroller_id ] ) ) {
				$report_users[ $patroller_id ]['id'] = $patroller_id; // Doing this to allow sorting by id. Numeric key for array will be lost
				$report_users[ $patroller_id ]['name'] = $p->field( 'patroller_id.display_name' );
				$report_users[ $patroller_id ]['team'] = '';
				$report_users[ $patroller_id ]['events'] = array();
			}


			// Create array to be converted in JSON with the list of all report_events the patroller attended
			$report_users[ $patroller_id ]['events'][ $event_id ] = array(
				'start' => $time_in->format( 'Y-m-d H:i' ),
				'end' => $time_out->format( 'Y-m-d H:i' ),
				'full_day' => ( $time_in <= $event->max_start && $time_out >= $event->min_end ? true : false ),
				'type' => $p->field( 'type' ),
				'notes' => $p->field( 'notes' )
			);

			/** Check if user has booked for this attendance
			 *  If so, remove the user from the bookings to leave only no_shows
			 *
			 */
			$i = array_search( $patroller_id, $event->bookings );
			if ( is_int( $i ) ) {
				$report_users[ $patroller_id ]['events'][ $event_id ]['booked'] = true;
				// Remove this booking so that only non-attending bookings are left at the end
				unset( $event->bookings[ $i ] );
			} else {
				$report_users[ $patroller_id ]['events'][ $event_id ]['booked'] = false;
			}


			// First time this event is encountered in report
			if ( empty( $report_events[ $event_id ] ) ) {
				$report_events[ $event_id ] = array(
					'date' => $event->start_date,
					'dow' => date( 'l', strtotime( $event->start_date ) ),
					'categories' => $event->categories_array
				);
			}

			// Increment the counter for this patrol type
			$report_events[ $event_id ][ $p->field( 'type' ) ]++;
		}

		/**
		 * Process "no shows" to append them to the appropriate event
		 */
		foreach ( $bookings as $event_id => $no_show ) {
			$report_events[ $event_id ]['no_show'] = $no_show;
			foreach ( $no_show as $no_show_uid ) {
				if ( empty( $report_users[ $no_show_uid ] ) ) {
					$u = get_userdata( $no_show_uid );
					$report_users[ $no_show_uid ]['name'] = $u->display_name;
				}

				$report_users[ $no_show_uid ]['no_show'][] = $event_id;
			}
		}

		$this->date_generated = new DateTime( 'now', new DateTimeZone( CA_TIMEZONE ) );

		//$report_users = self::sort($report_users, 'name');

		$this->report = array(
			'patrollers' => $report_users,
			'report_events' => $report_events,
			/*'no_shows' => ( empty( $bookings ) ? '' : $bookings ),*/
			'date_generated' => $this->date_generated->format( 'Y-m-d H:i:s' )
		);

		do_action( 'ca_report_generated', $this );
	}

	public function sort( array $data, string $field = "" ) {


		$stop = true;
	}

// TODO: Deal with TimeZones in all DateTime()

	private function event_query() {

		global $wpdb;

		$events_table = $wpdb->prefix . "em_events";

		// TODO Sanitize input for query

		$where = array();
		$join = array();

		$where[] = sprintf( "t.time_in >= '%s'", $this->date_range['from']->format( 'Y-m-d H:i:s' ) );
		$where[] = sprintf( "t.time_out < '%s'", $this->date_range['to']->format( 'Y-m-d H:i:s' ) );

		if ( ! empty( $this->args['event_id'] ) ) {
			$where[] = sprintf( "t.event_id = %u", intval( $this->args['event_id'] ) );
		}

		if ( ! empty( $this->args['user_id'] ) ) {
			$where[] = sprintf( "patroller_id.ID = %u", intval( $this->args['user_id'] ) );
		}

		if ( ! empty( $this->args['type'] ) ) {
			$where[] = sprintf( "t.type = '%s'", sanitize_text_field( $this->args['type'] ) );
		}


		// Group_id is BP_Groups
		if ( ! empty( $this->args['group_id'] ) ) {
			$join[] = sprintf(
				'INNER JOIN %s AS events ON events.event_id = t.event_id',
				$events_table
			);
			$where[] = sprintf( "events.group_id = %u", intval( $this->args['group_id'] ) );
		}

		/**
		 * Attendance categories are not part of the query for simplicity and to avoid huge SQL query.
		 * It is checked when the report is being built.
		 */

		// TODO: Optimize me not to have where2 var
		$where2 = implode( ' AND ', $where );
		// TODO: Optimize me not to have join2 var
		$join2 = implode( ' ', $join );


		return array(
			'where' => $where2,
			'orderby' => 't.time_in ASC',
			'limit' => -1,
			'join' => $join2,
			'pagination' => false,
			'expires' => 3600,
			'cache_mode' => 'transient'
		);
	}

	/*public static function sort( array $what, $key ) {

		$test = array();

		//Does work... problem is index are int so they can't be reorganized
		usort($what, function ($a,$b) use($key, &$test) {
			$test[] = "strcasecmp($a[$key],$b[$key]) " . strcasecmp($a[$key],$b[$key]);
			return strcasecmp($a[$key],$b[$key]);
			//return ($a[$key] < $b[$key]) ? -1 : 1;
			//return $a[$key]>$b[$key];
		});

		return $what;
	}*/

	public function __toString() {
		// TODO: Implement __toString() method.

		if ( empty( $this->report ) )
			return _( 'No report generated', CA_TEXTDOMAIN );

		return json_encode( $this->report );
	}
}